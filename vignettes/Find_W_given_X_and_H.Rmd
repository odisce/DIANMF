---
title: "Find W, given X and H"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Find W, given X and H}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## Introduction
 
This vignette demonstrates how to extract pure spectra $W$ given a matrix of mixed compounds $X$ and their respective pure elution profiles $H$. This method can be applied to both data levels, MS1 and MS2. Here, we will apply it to MS2 data.

First, we attach our packages, load the same test file used in the previous vignettes, and process the first 10 detected MS1 peaks.

```{r setup}
library(DIANMF)
```

```{r load mzML file, echo=TRUE }
file <- system.file("extdata", "test_data.mzml", package = "DIANMF")
```

```{r main function MS2 level, echo=TRUE }
MS2_features <- dia_nmf.f( mzML_path = file,
                          ms_level = "MS2",
                          peaks_by_xcms = TRUE, ms1_peaks = NULL, d.out = NULL,
                          ppm = 6, peakwidth = c(3,60), snthresh = 0,
                          prefilter = c(5,4000), mzCenterFun = "wMeanApex3",
                          integrate = 2, mzdiff = -0.001, noise = 0,
                          firstBaselineCheck = FALSE)
```

## Find W

The first peak does not have specific MS2 fragments because its range is out of the isolation windows ranges, so it was not fragmented in the MS2 level. Due to this, we will work with the second peak and extract its' MS2 raw matrix $X$ and elution profiles matrix $H$ from the MS2_features object.

```{r extract X and H, echo=TRUE }
peak.idx <- 2

MS2_raw_matrices <- extract_mixedMat(features = MS2_features, ms_level = 'MS2')
X <- MS2_raw_matrices[[peak.idx]]

H_ms2.l <- extract_pureMat(features = MS2_features, ms_level = 'MS2', H = TRUE)
H <- H_ms2.l[[peak.idx]]
# knitr::kable(head(H_ms2))
```

<span style="background-color: rgba(169, 169, 169, 0.4);">find_W()</span> is a function from *DIANMF*, that aims to find $W$ from $X$ and $H$. This function is based on the forward-backward algorithm and more specifically on the positive-projection algorithm. It takes inputs <span style="background-color: rgba(169, 169, 169, 0.4);">X</span>, <span style="background-color: rgba(169, 169, 169, 0.4);">H</span>, <span style="background-color: rgba(169, 169, 169, 0.4);">maxFBIteration</span>, and <span style="background-color: rgba(169, 169, 169, 0.4);">toleranceFB</span> parameters to iterate and find the best $W$. Every column of $W$ is a pure spectrum related to a compound in $X$.

```{r find A, echo=TRUE}
W <- find_W(X = X, H = H, maxFBIteration = 20, toleranceFB = 1e-5)
knitr::kable(W, row.names = FALSE)
```
