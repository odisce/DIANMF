---
title: "Process MS1 data level"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Process MS1 data level}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## Introduction
This vignette concerns the MS1 level data; it describes how to process an mzML file to identify its detected MS1 peaks.

Before we go on, we will attach the packages we use, expose the version of *DIANMF*.

```{r setup, warning=FALSE, message=FALSE}
library(DIANMF)

packageVersion("DIANMF")
```

## Data description
*DIANMF* supports the analysis of LC-MS and LC-MS/MS data that are imported with the MSnbase package and provided in mzML format.

For demonstration purposes and to speed up the processing of this vignette, we will analyze a tiny subset of human plasma samples spiked with a pool of 47 chemical compounds at 7 known concentrations (from 0 to 10 ng/mL for each metabolite). This data was analyzed in triplicate by SWATH DIA, as described in <https://www.mdpi.com/2218-1989/10/4/158>.

The data test is provided in our package. It is a subset from replicate 3 of the 10 ng/mL concentration file from 95-115 m/z, 62-78 seconds, and precursorMZ <= 160 at the MS2 level.

```{r load mzML file, echo=TRUE }
file <- system.file("extdata", "test_data.mzml", package = "DIANMF")
load("~/DIA_NMF_R_package/dianmf/data/data_example.rda")
```

We load our mzML file from **inst/extdata** or the MSnbase `r class(data_example)` object from **data** directory in the *DIANMF* package.

## Extract MS1 features 
To extract MS1 features from LC-MS or LC-MS/MS data, the MS1 pure spectrum for each identified MS1 peak in the raw mzML file must be obtained. The MS1 peaks are all signals in the sample produced by ions from the same originating component species and retrieved using chromatographic peak detection.

In *DIANMF*, the user has two choices:

1. Provide the MS1 peaks to be identified.
1. Detect them using the [xcms](https://bioconductor.org/packages/release/bioc/html/xcms.html) algorithm.

Below we identify detected peaks by xcms from the test-data file using the <span style="background-color: rgba(169, 169, 169, 0.4);">dia_nmf.f()</span> function by specifying these parameters: <span style="background-color: rgba(169, 169, 169, 0.4);">ms_level = "MS1"</span>, <span style="background-color: rgba(169, 169, 169, 0.4);">peaks_by_xcms = TRUE</span>, <span style="background-color: rgba(169, 169, 169, 0.4);">ms1_peaks = NULL</span> with some additional specific parameters of <span style="background-color: rgba(169, 169, 169, 0.4);">findChromPeaks()</span> function from [xcms](https://bioconductor.org/packages/release/bioc/html/xcms.html).

```{r main function MS1 level, echo=TRUE }
MS1_features <- dia_nmf.f( mzML_path = file,
                           ms_level = "MS1",
                           peaks_by_xcms = TRUE, ms1_peaks = NULL, d.out = NULL,
                           ppm = 6, peakwidth = c(3,60), snthresh = 0,
                           prefilter = c(5,4000), mzCenterFun = "wMeanApex3",
                           integrate = 2, mzdiff = -0.001, noise = 0,
                           firstBaselineCheck = FALSE )
```

The user can provide his MS1 peak matrix or data.frame R object in the <span style="background-color: rgba(169, 169, 169, 0.4);">ms1_peaks</span> parameter with <span style="background-color: rgba(169, 169, 169, 0.4);">peaks_by_xcms = FALSE</span>. The **mz**, **mzmin**, **mzmax**, **rt**, **rtmin**, **rtmax**, and **into** are sufficient information for every peak.

The MS1_features object contains information for every identified peak as the peak itself, the pure spectrum and elution profile (or chromatograms) for every pure component in the mixed data (called W_ms1 and H_ms1 respectively), and some other helpful information gained while processing the peak. For example, the pure spectra corresponding to the peaks can be extracted using the following function.

## MS1 pure spectra 

```{r MS1 pure spectra, echo=TRUE }
MS1_pure_spectra <- extrcat_pureSpect( features = MS1_features, spec_level = 'MS1' )
```

The <span style="background-color: rgba(169, 169, 169, 0.4);">extrcat_pureSpect()</span> method returned list of all extracted MS1 pure spectra. <span style="background-color: rgba(169, 169, 169, 0.4);">extrcat_pureSpect</span> objects are two-dimensional `r class(MS1_pure_spectra[[1]])` of two columns `r colnames(MS1_pure_spectra[[1]])`.

## Process one specific peak

To familiarize ourselves with the different functions in the *DIANMF* package, we will process one specific peak.

#### Detect and prepare MS1 peaks

The <span style="background-color: rgba(169, 169, 169, 0.4);">detect_peaks_by_xcms()</span> function applies chromatograms peak detection using xcms functions as its name suggests. The user can use any other software to do so or directly <span style="background-color: rgba(169, 169, 169, 0.4);">xcms::findChromPeaks()</span>. This method takes the `r class(data_example)` as input and does not take the mzML file.

```{r detect MS1 peaks using xcms, echo=TRUE, message=FALSE, warning=FALSE}
ms1_peaks.mat <- detect_peaks_by_xcms( rawData.onDiskMSnExp = data_example,
                                        ppm = 6, peakwidth = c(3,60), snthresh = 0,
                                        prefilter = c(5,4000), mzCenterFun = "wMeanApex3",
                                        integrate = 2, mzdiff = -0.001, noise = 0,
                                        firstBaselineCheck = FALSE )
  
ms1_peaks.df <- prepare_ms1_peaks(ms1_peaks = ms1_peaks.mat)
knitr::kable(head(ms1_peaks.df[, c(1:9)]))
```

The <span style="background-color: rgba(169, 169, 169, 0.4);">prepare_ms1_peaks()</span> function prepare the peaks as a `r class(ms1_peaks.df)` with increasing order of peaks **into**.

#### Choose the MS1 peak
```{r choose MS1 peak, echo=TRUE }
peak.idx <- 1
mz_prec <- ms1_peaks.df[peak.idx, 'mz']
rt_prec <- ms1_peaks.df[peak.idx, 'rt']
```

We are processing the first peak, with the highest **into** value. This peak is related to the MS1 precursor of mz `r round(mz_prec,4)` and rt `r round(rt_prec,4)`.

#### Extract the MS1 mixed matrix

The first step in determining the MS1 properties of this peak is to extract the associated MS1 data. Use the <span style="background-color: rgba(169, 169, 169, 0.4);">extract_ms_matrix.f()</span> function with <span style="background-color: rgba(169, 169, 169, 0.4);">iso_win_index = NULL</span> to do so.

```{r extract the mixed MS1 data as matrix, echo=TRUE}
ms1_mat <- extract_ms_matrix.f(peak.idx = peak.idx, ms1_peaks.df = ms1_peaks.df, rawData.onDiskMSnExp = data_example,
                                     ppm.n = 7, rt_index = TRUE, mz_range = NULL, iso_win_index = NULL)
knitr::kable(head(ms1_mat[, c(1:8)]))
```

ms1_mat is a `r class(ms1_mat)`, where the columns represent the extracted ion chromatograms (EICs) and rows (optionally) the actual retention time (rt) scans of the peak if <span style="background-color: rgba(169, 169, 169, 0.4);">rt_index = TRUE</span>.

#### NMF on the MS1 matrix

The main strength of our approach in identifying metabolites if using Non-negative matrix factorization (NMF) and not the traditional way: model peak selection. The [nGMCAs](https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6584797) NMF algorithm was used in our package for now.

Mathematically, ms1_mat ( or we will call it $X_{m,n}$) contains the components' sources mixed up in an unknown but linear way. The factorize (un-mix) model is 
\begin{align} \label{eq1}
      X \approx WH,
\end{align}
where $W \in \mathbf{R}^{m \times r}$ is the basis matrix and $H \in \mathbf{R}^{r \times n}$ is the coefficients matrix. Each column of $W$ is the unknown spectrum/source that is not negative, whereas each row of $H$ represents an elution profile that determines the contribution of each source, which is also non-negative. Thus, $n$ is the number of measurements, $m$ is the number of source samples, and $r$ is the number of pure sources.

The rank of factorization remains a challenge in NMF problems. However, it is robust in our case, meaning ranking over estimations is worse than assigning a fixed tiny rank. Until now, we have set it to three, so we are confident that one pure component is related to the precursor we are attempting to identify, one to another precursor, and the third may collect all noise in the matrix. 

```{r NMF MS1 data, echo=TRUE }
ms1_rank <- 3
ngmcas_res <- nGMCAs(X.m = ms1_mat, rank = ms1_rank,
                     maximumIteration = 10, maxFBIteration = 10, toleranceFB = 1e-5,
                     initialization_method = 'nndsvd')

W_ms1 <- ngmcas_res$S
H_ms1 <- ngmcas_res$A
```

The NMF is applied using <span style="background-color: rgba(169, 169, 169, 0.4);">nGMCAs()</span> function. W_ms1 and H_ms1 are `r class(W_ms1)`, representing the MS1 elution profiles (chromatograms) and pure spectra, respectively.

#### Extract the pure MS1 spectrum related to this peak

Usually, users are interested in the pure MS1 spectra. These spectra can be extracted using the <span style="background-color: rgba(169, 169, 169, 0.4);">extract_ms1_pure_spectrum()</span> method by specifying the mz of the peak (precursor), which will be used to choose the affiliated spectrum.

```{r extract the good pure MS1 spectrum, echo=TRUE }
ms1_pure_data <- extract_ms1_pure_spectrum(W_ms1 = W_ms1, mz_prec = mz_prec)
ms1_pure_spectrum <- ms1_pure_data$ms1_pure_spectrum
```
 
#### plot mixed and pure MS1 data

For the users' curiosity, looking at the pure and mixed data, EICS, and spectra will be nice. Here we will plot them using these two functions: <span style="background-color: rgba(169, 169, 169, 0.4);">plot_MS_eics()</span> and <span style="background-color: rgba(169, 169, 169, 0.4);">plot_MS_spectra()</span>.

```{r plot data, echo=TRUE, fig.height=6, fig.width=7.2}
choosen_comp_ms1 <- ms1_pure_data$comp_ms1

p_eics <- plot_MS_eics(ms_mixed = ms1_mat, ms_pure_H = H_ms1, ms_level = "MS1", rt_prec = rt_prec, choosen_comp = choosen_comp_ms1)
p_eics

p_spectra <- plot_MS_spectra(ms_mixed = ms1_mat, ms_pure_W = W_ms1, ms_level = "MS1", mz_prec, choosen_comp = choosen_comp_ms1)
p_spectra
```

