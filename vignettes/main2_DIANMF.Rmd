---
title: "*DIANMF*: Deconvolution of metabolomic SWATH DIA data using non-negative matrix factorization (NMF)"
author: "Diana Karaki"
date: "`r Sys.Date()`"
package: "`r pkg_ver('DIANMF')`"

vignette: >
  %\VignetteIndexEntry{main2_DIANMF}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: '`r system.file("bib", "references-vignette.bib", package = "DIANMF")`'
output: 
  BiocStyle::html_document:
    citation_package: natbib
    csl: nature.csl
    fig_caption: yes
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: false
    editor_options: 
      markdown: 
       wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```


# Introduction
Sequential window acquisition of all theoretical data-independent acquisition mass spectra (SWATH DIA) is essential for information-rich spectral annotations. However, the acquired MS2 spectra are hybrid mixtures, posing significant annotation challenges. We have developed the *DIANMF* R package for untargeted metabolomics processing. 

Non-negative matrix factorization is widely used for analyzing high-dimensional data and feature extraction  [@Fu_2019_NonnegativeMatrixFactorization]. It automatically extracts meaningful features from a set of non-negative linear mixtures. This non-negativity arises naturally in many real problems such as hyperspectral sensors  [@Brezini_2020_NMFBasedMethodHyperspectral], audio processing [@Fevotte_2009_NonnegativeMatrixFactorization], clustering [@Kim_2008_SparseNonnegativeMatrix], and spectrometry [@Dubroca_2012_WeightedNMFHighresolution]. It has been recently applied to LC-MS [@Rapin_2016_ApplicationNonnegativeMatrix]and has been shown superior to model peak algorithms for gas chromatography (GC)-MS data [@Smirnov_2019_ADAPGCApplicationClusteringAssisted]. Furthermore, on the assumption that for every metabolite, the existing information in the MS1 data correlates in the same sample with its MS2 data. Exploits this quantitative information to deconvolute complex SWATH DIA spectra.

The two existing approaches that address the issue of DIA data without relying on predefined spectral libraries for un-mixing are MS-DIAL [@Tsugawa_2015_MSDIALDataindependentMS] and DecoMetDIA [@Yin_DecometdiaDeconvolutionMultiplexed_2019]. These workflows are based on determining peak models for each precursor: the mixed elution profiles are decomposed as linear combinations of these peaks. Such a strategy, however, is not appropriate for small peaks whose retention time is close to more intense ones (co-eluting compounds). In such cases, the peak shape defined by the algorithm may encompass several analytical peaks and may not allow their proper deconvolution [@Smirnov_2019_ADAPGCApplicationClusteringAssisted].

NMF is not the only advantage of *DIANMF*. However, the methodology used to extract the mixed data and use the pure MS1 information for every peak to collect its MS2 data are essential aspects of our workflow. Every ion in the pure MS1 spectrum, depending on its $m/z$ value, was fragmented in a specific isolation window. This fact leads us to: from every window, we extract all MS2 fragments generated from the fragmented MS1 ions.

*DIANMF* provides a complete pipeline for the identification of untargeted metabolomics. It supports LC-MS and LC-MS/MS files as mzML files and ends with a list of features characterizing every metabolite in the raw biological sampleâ€”the procedure: (1) Chromatographic peak detection at the MS1 level. (2) For every MS1 peak $p$, construct the related MS1 matrix $X^1$ (every row of this matrix is an extracted ion chromatogram (EIC) of MS1 fragment/ion that may relate to the precursor $p$). (3) Factorize $X^1$ to extract the pure MS1 information related to $p$: pure MS1 spectrum $s1_p$ and its elution profile. (4) Extract the MS2 matrices from every isolation window $X^2_i$, using the information in $s1_p$. (5) Factorize the concatenation of these MS2 matrices $X^2$ using NMF to get the MS2 pure spectra $s2_p$. (6) Finally, match $s2_p$ to a library database to identify the precursor (metabolite).



advantages, or some results + convince people by my pure ms2 spectra ...



This vignette showcases the processing of metabolites in a small SWATH DIA LC-MS/MS data set using *DIANMF*. It consists of two main parts. The first part introduces different *DIANMF* functions and their parameters while identifying specific metabolites. The second part identifies all metabolites in the raw data using one primary *DIANMF* function (a wrapper function) and extracts the outputs from the features object.


# Hands-on

This part will focus on identifying specific detected metabolites. It give a quick overview of the *DIANMF* main workflow.

## Data import
For demonstration purposes and to speed up the processing of this document, we will analyze a tiny subset of real spiked data from [@BarbierSaintHilaire_ComparativeEvaluationData_2020]. In which human plasma samples spiked with a pool of 47 chemical compounds at 7 known concentrations (from 0 to 10~ng/mL for each metabolite) were analyzed in triplicate by SWATH DIA. A full scan MS event was followed by ten MS2 spectra collected from consecutive precursor ion isolation windows (20 to 50~Da each) on an Orbitrap Fusion instrument operated in the positive ionization mode. A stepped Normalized Collision Energy (NCE) was used to optimize the fragmentation: each MS2 spectrum is the mean of spectra acquired at 30\% $\pm$ 20\% NCE. MS1 and MS2 spectra were recorded at a resolution of 120,000 and 15,000 (at $m/z$ 200), respectively.


The data test mzML file is provided in our package. It is a subset from replicate 3 of the 10 ng/mL concentration file from 100-290 $m/z$, 425-440 seconds, and precursorMZ $<=$ 280 at the MS2 level. The data set consists of the "Dextromethorphan" spiked compound of $m/z$ 272.2009 and $rt$ 432 seconds.

Let us load our package and the dataset mzML file.

```{r load mzML file, echo=TRUE }
# load  the package
library(DIANMF)
packageVersion("DIANMF")

# load the dataset
file <- system.file("extdata", "test_data.mzml", package = "DIANMF")
```


## Chromatographic peak detection

The first main step in processing raw metabolomic data is to detect the ion peaks at the MS1 level. The MS1 peaks are all signals in the sample produced by ions from the same originating component species and retrieved using chromatographic peak detection. In *DIANMF*, the user has two choices:

1. Detect them by [xcms](https://bioconductor.org/packages/release/bioc/html/xcms.html) algorithm: using the <span style="background-color: rgba(169, 169, 169, 0.4);">DIANMF::detect_peaks_by_xcms()</span> function which is based on the <span style="background-color: rgba(169, 169, 169, 0.4);">xcms::findChromPeaks()</span> method or by calling the xcms function directly.

1. Provide the MS1 peaks as a matrix or data.frame R object, involving these sufficient information for every peak:  **mz**, **mzmin**, **mzmax**, **rt**, **rtmin**, **rtmax**, and **into**.

<span style="background-color: rgba(169, 169, 169, 0.4);"> detect_peaks_by_xcms()</span> parameters are: 

* <span style="background-color: rgba(169, 169, 169, 0.4);"> rawData.onDiskMSnExp</span> mzML file mass-spectrometry data.
* <span style="background-color: rgba(169, 169, 169, 0.4);">ppm</span> numeric(1) defining the maximal tolerated m/z deviation in consecutive scans in parts per million (ppm) for the initial ROI definition.
* <span style="background-color: rgba(169, 169, 169, 0.4);">peakwidth</span> numeric(2) with the expected approximate peak width in chromatographic space. Given as a range (min, max) in seconds.
* <span style="background-color: rgba(169, 169, 169, 0.4);">snthresh</span> numeric(1) defining the signal to noise ratio cutoff.
* <span style="background-color: rgba(169, 169, 169, 0.4);">prefilter</span> numeric(2) c(k, I) specifying the prefilter step for the first analysis step (ROI detection). Mass traces are only retained if they contain at least k peaks with intensity >= I.


To import the mass-spectrometry raw data from the mzML file, we will use the <span style="background-color: rgba(169, 169, 169, 0.4);">readMSData()</span> function from <span style="background-color: rgba(169, 169, 169, 0.4);"> MSnbase</span> package. Just by specifying the mzML file path in <span style="background-color: rgba(169, 169, 169, 0.4);">files</span> and <span style="background-color: rgba(169, 169, 169, 0.4);"> mode = "onDisk"</span> in order to only generates the object and the raw data is accessed on disk when needed without loading it in the memory.

```{r detect MS1 peaks using xcms, echo=TRUE, message=FALSE, warning=FALSE}
library(MSnbase)

# load the metadata (mass-spectrometry data)
data_test <- MSnbase::readMSData(files = file, mode = "onDisk")
data_test

# detect MS1 peaks using xcms
ms1_peaks.mat <- detect_peaks_by_xcms( rawData.onDiskMSnExp = data_test,
                                        ppm = 6, peakwidth = c(3,60), snthresh = 0,
                                        prefilter = c(5,4000), mzCenterFun = "wMeanApex3",
                                        integrate = 2, mzdiff = -0.001, noise = 0,
                                        firstBaselineCheck = FALSE )
```

*DIANMF* processes MS1 peaks sequentially, starting with the peak of the highest **into**. <span style="background-color: rgba(169, 169, 169, 0.4);">prepare_ms1_peaks()</span> function prepares the peaks in the proper form.

```{r prepare MS1 peak, echo=TRUE, message=FALSE, warning=FALSE}
# prepare the MS1 peaks
ms1_peaks.df <- prepare_ms1_peaks(ms1_peaks = ms1_peaks.mat)

knitr::kable(head(ms1_peaks.df[, c(1:7)]), row.names = FALSE)
```

Each row in this `r class(ms1_peaks.df)` represents the MS1 peak. Every peak is related to a specific precursor, identifying a metabolite in the raw data. Let us proceed with processing a specific MS1 peak, which is related to "Dextromethorphan". This compound is the peak in the first row.
 

```{r choose MS1 peak, echo=TRUE }
# peak index in the raw dataset
peak.idx <- 1

# peak mz and rt
mz_prec <- ms1_peaks.df[peak.idx, 'mz']
rt_prec <- ms1_peaks.df[peak.idx, 'rt']
```



The first mass spectrometer used in an LC-MS/MS setup includes an ionization source, where the effluent from the LC column is nebulized and ionized, resulting in charged particles. These charged particles are sorted by their mass-to-charge ($m/z$) ratios at each retention time point, creating the MS1 spectrum. In SWATH DIA, fragmentation or MS2 acquisitions are continuously performed on sequential windows to cover the entire $m/z$ range of the MS1 scan. As a result, each MS2 spectrum contains a mixture of fragments from all MS1 precursors within the same fragmentation window. Although the direct link between each MS1 precursor and its corresponding MS2 ions is lost, **all fragments originating from the same MS1 parent ion exhibit the same elution profile**.

Compounds and related ions, such as adducts, losses, and isotopes, have similar retention times due to their chemical structures despite variations in their $m/z$ values. Thus, they are expected to belong to the same MS1 scan, which is crucial for our approach. We aim to isolate the pure MS1 spectrum for each MS1 peak, including the precursor fragments and all associated ions. We extracted the peak MS1 data from the apex scan and then applied NMF to deconvolute its pure data. This refined MS1 scan is used to identify the mixed MS2 data corresponding to the peak. In the MS2 stage, all ions present in the pure MS1 spectrum are fragmented across different isolation windows, depending on their $m/z$ values. The MS2-extracted ion chromatograms of the associated MS1 ions are retrieved from each isolation window, forming a mixed matrix.



## Construct MS1 mixed matrix

In this step, our goal is to retrieve the clean MS1 spectrum corresponding to the target peak. We extract the extracted ion chromatograms (EICs) for all MS1 fragments in the spectrum at the peak apex scan. These EICs will be arranged row-wise in a matrix, with retention time scans placed in the columns.

The method <span style="background-color: rgba(169, 169, 169, 0.4);">DIANMF::extract_ms_matrix.f()</span> creates such matrix. This function has numerous critical arguments to select depending on the data type the user wants to retrieve (MS1 or MS2). The parameters are:

* <span style="background-color: rgba(169, 169, 169, 0.4);">peak.idx</span> peak index.
* <span style="background-color: rgba(169, 169, 169, 0.4);">ms1_peaks.df</span> MS1 peaks `r class(ms1_peaks.df)`.
* <span style="background-color: rgba(169, 169, 169, 0.4);">rawData.onDiskMSnExp</span> OnDiskMSnExp object for onDisk mode.
* <span style="background-color: rgba(169, 169, 169, 0.4);">ppm.n</span> defining the m/z tolerated deviation in parts per million (ppm).
* <span style="background-color: rgba(169, 169, 169, 0.4);">rt_index</span> if *TRUE* use the real retention time axis of the peak, else *FALSE*.
* <span style="background-color: rgba(169, 169, 169, 0.4);">mz_range</span> *NULL* if no restriction on the mz ranges, else an mz range. 
* <span style="background-color: rgba(169, 169, 169, 0.4);">iso_win_index</span> SWATH isolation window index, just for MS2 level. For MS1 data *iso_win_index = NULL*.

For MS1 level, the <span style="background-color: rgba(169, 169, 169, 0.4);">rt_index = TRUE</span>, <span style="background-color: rgba(169, 169, 169, 0.4);">mz_range = NULL</span> and <span style="background-color: rgba(169, 169, 169, 0.4);">iso_win_index = NULL</span> are fixed.

```{r extract the mixed MS1 matrix, echo=TRUE}
X1 <- extract_ms_matrix.f(peak.idx = peak.idx, ms1_peaks.df = ms1_peaks.df, rawData.onDiskMSnExp = data_test,
                                     ppm.n = 7, rt_index = TRUE, mz_range = NULL, iso_win_index = NULL)
```

*X1* is a `r class(X1)`, where every row represents an extracted ion chromatograms among the actual retention time (rt) scans of the peak. It is possible to plot this mixed MS1 data using <span style="background-color: rgba(169, 169, 169, 0.4);">plot_MS_eics()</span> function. The user should provide the <span style="background-color: rgba(169, 169, 169, 0.4);">ms_mixed</span> and specify the <span style="background-color: rgba(169, 169, 169, 0.4);">ms_level</span>.
 
```{r show the mixed MS1 matrix, echo=TRUE}
mixed_eics <- plot_MS_eics(ms_mixed = X1, ms_level = "MS1", rt_prec = rt_prec)
mixed_eics
```
... plot also here the mixed MS1 spectrum .......


All fragments from the same MS1 parent ion have the same elution profile. Without integrating other compounds, we are engaging in the elution profiles (or chromatograms) related to the precursor at rt `r round(rt_prec,4)`. In other words, we want to un-mix or extract this mixed data's main features (basis). These bases are of positive intensities, and their corresponding spectra are positive and sparse in real life. Thus, one of the main strengths of our approach to extracting pure data is the non-negative matrix factorization (NMF), which is different from the traditional method of model peak selection.


## MS1 data factorization

*X1* (or we will call it $X_{m,n}$ in this subsection) contains the components' sources mixed up in an unknown but linear way. NMF aims to approximate $X_{m,n}$ such that: 

\begin{equation}
\label{eq1}
X_{m,n} \approx W_{m,r} H_{r,n},
\end{equation}

where $W \in \mathbf{R}^{m \times r}$ is the basis matrix and $H \in \mathbf{R}^{r \times n}$ is the coefficients matrix. Each column of $W$ is the unknown spectrum/source that is not negative, whereas each row of $H$ represents an elution profile that determines the contribution of each source, which is also non-negative. Thus, $n$ is the number of measurements, $m$ is the number of source samples, and $r$ is the number of pure sources exist in $X_{m,n}$.

The rank of factorization ($r$) remains a challenge in NMF problems. However, it is robust in our case, meaning ranking over estimations is worse than assigning a fixed tiny rank. Until now, we have set it to three, so we are confident that one pure component is related to the precursor we are attempting to identify, one to another precursor, and the third may collect all noise in the matrix. 

Solving problem \eqref{eq1} can be written under the constrained form:

\begin{align} \label{eq2} 
\underset{\substack{W, H \geqslant 0}}{\text{argmin}} \, \mathcal{D}(X \parallel WH) + J(W). 
\end{align}
$\mathcal{D}$ is a divergence function, as the Euclidean distance $(l_2)$, it measures the discrepancy between the data $X$ and it's factorization $WH$. $J$ is an optional regularization function providing prior information about the spectra.

Rapin \textit{et al.} introduced the nGMCA$^s$ [@Rapin_2016_ApplicationNonnegativeMatrix], [@Rapin_2013_SparseNonNegativeBSS] algorithm, which aims to solve the sparse non-negative blind source separation. This algorithm minimizes the following optimization problem: 
\begin{align} \label{sp_W}
    \underset{\substack{W, H}}{\text{argmin}} \, \frac{1}{2}||X - WH||^2_2 + \lambda ||W||_1 + i^{+}(W) +  i^{+}(H),
\end{align}
where $i^{+}$ is the characteristic function of the non-negative orthant that enforces the non-negative constraints; it is applied point-wise on every entry of $W$ and $H$: 
\vspace{-0.1cm}
\begin{align}
i^{+}(w_{i,j}) =
\begin{cases}
0 & \text{if} \quad w_{i,j} \geq 0. \\
+ \infty  & \text{otherwise.}
\end{cases}
\end{align}

nGMCA$^s$ alternatively minimizes the constrained sub-problems to obtain stable solutions with the sought structure: 

1. Fix H, sub-problem in W is: \begin{align}
\underset{\substack{W}}{\text{argmin}} \, \frac{1}{2}||X - WH||^2_2 + \lambda ||W||_1 + i^{+}(W).
\end{align}
1. Fix W, sub-problem in H is: \begin{align}
\underset{\substack{H}}{\text{argmin}} \, \frac{1}{2}||X - WH||^2_2 + i^{+}(H).
\end{align}

These sub-problems can be solved by the forward-backward splitting algorithm (FBS) [@Combettes_2005_SignalRecoveryProximal] from proximal splitting methods. $nGMCAs$ algorithm is coded in <span style="background-color: rgba(169, 169, 169, 0.4);">DIANMF::nGMCAs()</span> function. The user should provide:

* <span style="background-color: rgba(169, 169, 169, 0.4);">X.m</span> mixed matrix.
* <span style="background-color: rgba(169, 169, 169, 0.4);">rank</span> number of pure compounds in the mixed matrix; rank of factorization.
* <span style="background-color: rgba(169, 169, 169, 0.4);">initialization_method</span> For MS1 data, it should be "random" ( randomly initialize $W$ and $H$) or "nndsvd" (initialize $W$ and $H$ based on the non-negative double singular value decomposition). 

```{r NMF MS1 data, echo=TRUE }
ms1_rank <- 3
ngmcas_res <- nGMCAs(X.m = X1, rank = ms1_rank,
                     maximumIteration = 10, maxFBIteration = 10, toleranceFB = 1e-5,
                     initialization_method = 'nndsvd')

W_ms1 <- ngmcas_res$S
H_ms1 <- ngmcas_res$A
```

MS1 Pure spectra and elution profiles are stored in $W_{ms1}$ and $H_{ms1}$, respectively. One of the pure sources is related to the peak we are processing. The spectrum of the maximum intensity at the fragment of mz equal to the peak mz: `r round(mz_prec,4)` corresponds to this MS1 precursor. And can be retrieved by <span style="background-color: rgba(169, 169, 169, 0.4);">extract_ms1_pure_spectrum()</span> given <span style="background-color: rgba(169, 169, 169, 0.4);">W_ms1</span> and  <span style="background-color: rgba(169, 169, 169, 0.4);">mz_prec</span>.

```{r extract the good pure MS1 spectrum, echo=TRUE }
ms1_pure_data <- extract_ms1_pure_spectrum(W_ms1 = W_ms1, mz_prec = mz_prec)

# ms1 pure spectrum of the peak
ms1_pure_spectrum <- ms1_pure_data$ms1_pure_spectrum

# index of the corresponding compound
comp_ms1 <- ms1_pure_data$comp_ms1
```

For the users' curiosity, we will plot the pure and mixed data: EICS and spectra using <span style="background-color: rgba(169, 169, 169, 0.4);">plot_MS_eics()</span> and <span style="background-color: rgba(169, 169, 169, 0.4);">plot_MS_spectra()</span>.

```{r plot data, echo=TRUE, fig.height=6, fig.width=7.2}
p_eics <- plot_MS_eics(ms_mixed = X1, ms_pure_H = H_ms1, ms_level = "MS1", rt_prec = rt_prec, choosen_comp = comp_ms1)
p_eics

p_spectra <- plot_MS_spectra(ms_mixed = X1, ms_pure_W = W_ms1, ms_level = "MS1", mz_prec, choosen_comp = comp_ms1)
p_spectra
```

*DIANMF* package is designed to process SWATH DIA data. To accomplish this, passing through the MS1 level is necessary in our methodology. Nonetheless, it is also possible to process only MS1 data, as demonstrated previously. 

Let us examine the fragments detected in the MS1 pure spectrum of 'Dextromethorphan.' Some MS1 ions appear as peaks within our original peak matrix. These ions should not be subjected to further fragmentation if they are closely associated with the processed precursor rather than another precursor. Thus, after every MS1 peak processing, we highlighted these ions in the peaks using `r class(ms1_peaks.df)` to prevent redundant processing of the same precursor. 

Accurately identifying the fragment ion signals corresponding to each MS1 chromatographic peak is a complex challenge. In the xcms framework, the MS2 spectrum of each fragment ion must be reconstructed using the available MS2 data (i.e., the chromatographic peaks detected at the MS2 level). Specifically, for SWATH data, the fragment ion signals should be found within the **same isolation window** containing the precursor ion's $m/z$, and the chromatographic peak profile of the MS2 peaks should exhibit similar retention times and shapes to the MS1 peak of the precursor. However, we disagree with the first assumption. Assuming that the pure MS2 data for each peak aligns with the MS1 data is more reasonable. Additionally, the MS1 pure spectrum ions often have significantly different $m/z$ values from the precursor's $m/z$, indicating that these ions were fragmented in **distinct isolation windows** at the MS2 level. 



## Extract MS2 mixed matrices

As described in the introduction, all ions within predefined isolation windows are fragmented in SWATH mode. The definition of these isolation windows (SWATH pockets) is imported from the metadata of the mzML file. Below we inspect the respective information using <span style="background-color: rgba(169, 169, 169, 0.4);">DIANMF::isolationWindows.range()</span> function given the `r class(data_test)` raw data. The upper and lower isolation window $m/z$ bounds are available within "LowerMz" and "UpperMz" respectively.

```{r SWATH isolation windows, echo=TRUE }
info.swath <- isolationWindows.range(data_test)
knitr::kable(info.swath)
```

Ions from the pure MS1 spectrum will be grouped according to the isolation window in which they were fragmented. The same method to retrieve MS1 data for the precursor ion will be applied to extract MS2 EICs from each companion window corresponding to each MS1 ion. As a result, the isolation windows will produce multiple MS2 mixed matrices. By doing this, we are sure all information related to this MS1 precursor in this raw file is extracted.  

Below we extracted the MS2 matrices using <span style="background-color: rgba(169, 169, 169, 0.4);">extract_ms2_matrices()</span>. This function inherits the <span style="background-color: rgba(169, 169, 169, 0.4);">extract_ms_matrix.f()</span> function. It determine in which isolation windows the MS1 ions in <span style="background-color: rgba(169, 169, 169, 0.4);">ms1_pure_spectrum</span> and loop over them in <span style="background-color: rgba(169, 169, 169, 0.4);">info.swath</span> parameter.

```{r extract the mixed MS2 data as matrix, echo=TRUE }
res_ms2 <- extract_ms2_matrices(peak.idx = peak.idx, ms1_peaks.df = ms1_peaks.df,
                                ppm.n = 7, ms1_pure_spectrum = ms1_pure_spectrum,
                                rawData.onDiskMSnExp = data_test, info.swath = info.swath )

# concatenate the MS2 matrices
X2 <- do.call(rbind, res_ms2)
```

*res_ms2* is a `r class(res_ms2)` of matrices extracted from each isolation window containing MS2 data for this peak. This MS2 data will be concatenated into `r class(X2)` *X2* and factorized together.


## MS2 data factorization

The same NMF algorithm nGMCA$^s$ is used for factorizing the MS2 matrix. The <span style="background-color: rgba(169, 169, 169, 0.4);">initialization_method</span> here, can be *random*, *nndsvd* and even *subSample*. *subSample* method initialize $H$ by the MS1 pure elution profiles *H_ms1* and solves the optimization sub-problem \eqref{sp_W} to initialize $W$.

```{r NMF MS2 data, echo=TRUE }
ms2_rank <- 3
ngmcas_res <- nGMCAs(X.m = X2, rank = ms2_rank,
                     maximumIteration = 10, maxFBIteration = 10, toleranceFB = 1e-5,
                     initialization_method = 'subSample', H_sub = H_ms1)

W_ms2 <- ngmcas_res$S
H_ms2 <- ngmcas_res$A
```

MS2 Pure spectra and elution profiles are stored in *W_ms2* and *H_ms2*, respectively. 

The MS2 pure spectra related to the processed peak is of the same index as the MS1 spectrum. Nevertheless, to inspect *W_ms2*, we will calculate the correlation between:

1. corresponding MS1 elution profile <span style="background-color: rgba(169, 169, 169, 0.4);">chromo_main</span>
1. MS2 elution profiles <span style="background-color: rgba(169, 169, 169, 0.4);">chromos</span>,

using the function <span style="background-color: rgba(169, 169, 169, 0.4);">elutions_corelation()</span> it choose the best corelation value. In all cases *comp_ms1* and *comp_ms2* are equal.

```{r choose the good MS2 spectrum, echo=TRUE }
comp_ms1

comp_ms2 <- elutions_corelation(chromo_main = H_ms1[comp_ms1, ], chromos = H_ms2)
comp_ms2
```

To plot MS2 data, use the same functions <span style="background-color: rgba(169, 169, 169, 0.4);">plot_MS_eics()</span> and <span style="background-color: rgba(169, 169, 169, 0.4);">plot_MS_spectra()</span> with <span style="background-color: rgba(169, 169, 169, 0.4);">ms_level = MS2</span>.

```{r plot data2, echo=TRUE, fig.height=6, fig.width=7.2}
p_eics <- plot_MS_eics(ms_mixed = X2, ms_pure_H = H_ms2, ms_level = "MS2", rt_prec = rt_prec, choosen_comp = comp_ms2)
p_eics

p_spectra <- plot_MS_spectra(ms_mixed = X2, ms_pure_W = W_ms2, ms_level = "MS2", mz_prec, choosen_comp = comp_ms2)
p_spectra
```


## Extract the MS2 Pure Spectrum
Finally, we can extract the pure MS2 spectra related to the peak. This spectrum contains MS2 fragments of the precursor, the precursor losses, adducts, and their isotopes. Use <span style="background-color: rgba(169, 169, 169, 0.4);">choose_ms2_pure_spectrum()</span> to extract the choosen MS2 spectrum by providing <span style="background-color: rgba(169, 169, 169, 0.4);">W_ms2</span> and <span style="background-color: rgba(169, 169, 169, 0.4);">choosen_comp = comp_ms1 or comp_ms2</span>.

```{r extract MS2 spectrum, echo=TRUE }
ms2_pure_spectrum <- choose_ms2_pure_spectrum(W_ms2 = W_ms2, choosen_comp = comp_ms2)
```

To extract the specific MS2 spectrum of the precursor, which contains just the precursor if it still exists after fragmentation and its fragments, we provided the <span style="background-color: rgba(169, 169, 169, 0.4);">filter_ms2_spectrum()</span> function. It takes:

* <span style="background-color: rgba(169, 169, 169, 0.4);">ms2_pure_spectrum</span> MS2 pure spectrum extracted from *W_ms2*.
* <span style="background-color: rgba(169, 169, 169, 0.4);">ms2_matrices</span> MS2 matrices extracted from every isolation window.
* <span style="background-color: rgba(169, 169, 169, 0.4);">mz_prec</span> MS1 peak mz value.
* <span style="background-color: rgba(169, 169, 169, 0.4);">info.swath</span> SWATH isolation windows *info.swath*.

```{r choose the specific MS2 spectrum, echo=TRUE }
ms2_pure_spectrum_specific <- filter_ms2_spectrum(ms2_pure_spectrum = ms2_pure_spectrum, ms2_matrices = res_ms2, mz_prec = mz_prec, info.swath = info.swath)
```

## Identify metabolites
This MS2 pure spectrum characterizes the MS1 peak. It is matched against our in-house database of reference spectra using the mean of three classical scores:

* The dot product: $\sum (I_{measured} \times I_{library})^2 / (\sum I^2_{measured} \times \sum I^2_{library})$
* The inverse dot product: same as the dot product but restricted to the fragments common to the query and reference spectra.
* The percentage of reference peaks found in the query spectrum: (matched fragments) / (reference fragments)

These scores can be calculated using these *DIANMF* functions:

* <span style="background-color: rgba(169, 169, 169, 0.4);">GetSimpleDotProductSimilarity()</span>.
* <span style="background-color: rgba(169, 169, 169, 0.4);">GetPresenceSimilarity()</span>.
* <span style="background-color: rgba(169, 169, 169, 0.4);">getReverseSearchingSimilarity()</span>. 

or, directly by the main function <span style="background-color: rgba(169, 169, 169, 0.4);">match_pure_scores2()</span>. The function parameters are:

* <span style="background-color: rgba(169, 169, 169, 0.4);">polarity</span> *POS* or *NEG*.
* <span style="background-color: rgba(169, 169, 169, 0.4);">mz_prec</span> precursor mz value.
* <span style="background-color: rgba(169, 169, 169, 0.4);">data_base</span> library database.
* <span style="background-color: rgba(169, 169, 169, 0.4);">measured_spectra</span> experimental pure spectrum.
* <span style="background-color: rgba(169, 169, 169, 0.4);">mz_tol</span>: mz tolerance to bin the ions.
 
The compound from the database with the highest matching mean score above 0.3 is assigned to the MS1 precursor.

```{r match the spectrum, echo=TRUE }
# the database is included in the package

# calculate the 3 scores
scores <- match_pure_scores2(polarity = 'POS', mz_prec = mz_prec, data_base = sub_database, measured_spectra = ms2_pure_spectrum_specific)
scores

# extract the best match spectrum
spect_idx <- as.numeric(scores[ which.max(scores$total_score) , 'ref_spectrum_index'])
reference_spectrum <- sub_database$spectra[[ spect_idx ]]@spectrum

# plot measured vs library spectra
p <- plot_spectra_vs(measured_spectrum = ms2_pure_spectrum_specific, library_spectrum = reference_spectrum)
p
```

Our extracted spectrum matched correctly with the library spectrum of `r scores$name.`, (see scores$name.). It fits relatively well with the best-match library spectrum, with high scores of `r scores$dot_prod`, `r scores$rev_prod`, and `r scores$presence` for the dot product, inverse dot product, and presence of fragments, respectively. The peak representing the precursor (the highest peak) still exists in both spectra with many other fragments. Also, two groups of peaks with slight differences in $m/z$ can be observed by closely inspecting the spectrum. These could represent fragments from isotopes of the original compound. 


The first pure MS2 spectrum extracted .......   contains isotopes of the compound and the compound's losses and adducts. DIA MS2 data, since all ions at a given retention time are fragmented from different MS2 isolation windows, can contain such fragments.

..... change the last sentence ...... 

... add details about the isotopes, adducts, indicated them ....


#  *DIANMF* outlook

## Process all metabolites
<span style="background-color: rgba(169, 169, 169, 0.4);">dia_nmf.f()</span> function is a wrapper for the main *DIANMF* methods. The user can process the whole raw file by giving the following parameters:

1. <span style="background-color: rgba(169, 169, 169, 0.4);">mzML_path</span>= mzML file path.
1. <span style="background-color: rgba(169, 169, 169, 0.4);">ms_level = "MS2".</span> 
1. <span style="background-color: rgba(169, 169, 169, 0.4);">peaks_by_xcms = TRUE,</span>
1. and some <span style="background-color: rgba(169, 169, 169, 0.4);">xcms::findChromPeaks()</span> parameters.

```{r main function MS2 level, echo=TRUE }
MS2_features <- dia_nmf.f( mzML_path = file,
                       ms_level = "MS2",
                       peaks_by_xcms = TRUE, 
                       ppm = 6, peakwidth = c(3,60), snthresh = 0,
                       prefilter = c(5,4000), mzCenterFun = "wMeanApex3",
                       integrate = 2, mzdiff = -0.001, noise = 0,
                       firstBaselineCheck = FALSE )
```

The MS1 peaks are all signals in the sample produced by ions from the same originating component species and retrieved using chromatographic peak detection. In *DIANMF*, the user has two choices:

* Detect them using the [xcms](https://bioconductor.org/packages/release/bioc/html/xcms.html) algorithm.
* Provide the MS1 peaks.

MS1 peaks can be detected using the <span style="background-color: rgba(169, 169, 169, 0.4);">detect_peaks_by_xcms()</span> *DIANMF* function based on the <span style="background-color: rgba(169, 169, 169, 0.4);">xcms::findChromPeaks()</span> method or by calling the xcms function directly.

<span style="background-color: rgba(169, 169, 169, 0.4);"> detect_peaks_by_xcms()</span> needs:

* <span style="background-color: rgba(169, 169, 169, 0.4);"> rawData.onDiskMSnExp</span>: mzML file mass-spectrometry data , read by <span style="background-color: rgba(169, 169, 169, 0.4);"> MSnbase::readMSData()</span> function. 
* tuning some <span style="background-color: rgba(169, 169, 169, 0.4);">xcms::findChromPeaks()</span> parameters such as <span style="background-color: rgba(169, 169, 169, 0.4);">ppm</span>, <span style="background-color: rgba(169, 169, 169, 0.4);">peakwidth</span>, <span style="background-color: rgba(169, 169, 169, 0.4);">snthresh</span>, <span style="background-color: rgba(169, 169, 169, 0.4);">prefilter</span>, etc.

Note: if the user provides his MS1 peak matrix or data.frame R object, **mz**, **mzmin**, **mzmax**, **rt**, **rtmin**, **rtmax**, and **into** are sufficient information for every peak.


## Export results
MS2_features or MS1_features are R objects that consist of all peaks processing information. Such as the MS1 peaks, *W_ms1*, *H_ms1*, *W_ms2*, *H_ms2*, the MS1 pure spectrum, the MS2 pure spectrum and the specific one. In *DIANMF*, we provided some functions to extract the information needed:

1. <span style="background-color: rgba(169, 169, 169, 0.4);">extract_pureSpect(features, spec_level)</span>; spec_level can be *MS1*, *MS2* or *MS2_specific*.
1. <span style="background-color: rgba(169, 169, 169, 0.4);">extract_mixedMat(features, ms_level)</span>; ms_level is *MS1* or *MS2*. 
1. <span style="background-color: rgba(169, 169, 169, 0.4);">extract_pureMat(features, ms_level, H)</span>; if H == *TRUE* extract H matrices else extract W.

```{r extract pure spectra, echo=TRUE }
# extract MS1 pure spectra
ms1_spectra <- extract_pureSpect(features = MS2_features, spec_level = "MS1")

# extract MS2 pure spectra
ms2_spectra <- extract_pureSpect(features = MS2_features, spec_level = "MS2")

# extract the precursors specific MS2 pure spectra
ms2_SpecificSpectra <- extract_pureSpect(features = MS2_features, spec_level = "MS2_specific")
```

```{r extract pure matrices, echo=TRUE }
# extract W_ms1 matrices
Ws_ms1 <- extract_pureMat(features = MS2_features, ms_level = "MS1", H = FALSE )

# extract H_ms1 matrices
Hs_ms1 <- extract_pureMat(features = MS2_features, ms_level = "MS1", H = TRUE)

# extract W_ms2 matrices
Ws_ms2 <- extract_pureMat(features = MS2_features, ms_level = "MS2", H = TRUE)

# extract H_ms2 matrices
Hs_ms2 <- extract_pureMat(features = MS2_features, ms_level = "MS2", H = FALSE)
```


# Appendix


# Cheat Sheet


# Session info
Here is the output of `sessionInfo()` on the system on which this document was compiled:

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References

